// server.js
const express = require('express');
const cors = require('cors');
const Web3 = require('web3');
const Twitter = require('twitter-api-v2');
const mongoose = require('mongoose');

const app = express();
const port = process.env.PORT || 3000;

// 中间件
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// 数据库连接
mongoose.connect('mongodb://localhost:27017/bags_tokens', {
    useNewUrlParser: true,
    useUnifiedTopology: true
});

// 数据模型
const TokenSchema = new mongoose.Schema({
    name: String,
    symbol: String,
    address: String,
    twitterHandle: String,
    creatorWallet: String,
    liquidity: Number,
    txHash: String,
    createdAt: { type: Date, default: Date.now },
    status: { type: String, default: 'pending' }
});

const Token = mongoose.model('Token', TokenSchema);

// Twitter客户端
const twitterClient = new Twitter({
    appKey: process.env.TWITTER_API_KEY,
    appSecret: process.env.TWITTER_API_SECRET,
    accessToken: process.env.TWITTER_ACCESS_TOKEN,
    accessSecret: process.env.TWITTER_ACCESS_SECRET,
});

// Web3配置
const web3 = new Web3(process.env.BSC_RPC_URL);
const factoryABI = [...]; // 工厂合约ABI
const factoryAddress = process.env.FACTORY_ADDRESS;
const factoryContract = new web3.eth.Contract(factoryABI, factoryAddress);

// 私钥用于自动交易
const privateKey = process.env.PRIVATE_KEY;
const wallet = web3.eth.accounts.privateKeyToAccount(privateKey);
web3.eth.accounts.wallet.add(wallet);

// API路由
app.get('/api/recent-tokens', async (req, res) => {
    try {
        const tokens = await Token.find()
            .sort({ createdAt: -1 })
            .limit(10);
        res.json(tokens);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/create-token', async (req, res) => {
    try {
        const { name, symbol, twitterHandle, liquidity } = req.body;
        
        // 验证输入
        if (!name || !symbol || !twitterHandle || !liquidity) {
            return res.status(400).json({ error: '缺少必要参数' });
        }
        
        // 检查用户限制
        const userTokens = await Token.countDocuments({ 
            twitterHandle,
            createdAt: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
        });
        
        if (userTokens >= 3) {
            return res.status(429).json({ error: '达到每日创建限制' });
        }
        
        // 在数据库中创建记录
        const tokenRecord = new Token({
            name,
            symbol,
            twitterHandle,
            status: 'processing'
        });
        
        await tokenRecord.save();
        
        // 发送推文通知
        await twitterClient.v2.tweet(
            `@${twitterHandle} 正在为您创建 ${name} (${symbol}) 代币，请稍候... ⏳`
        );
        
        // 异步处理代币创建
        processTokenCreation(tokenRecord, req.body);
        
        res.json({ 
            success: true, 
            message: '代币创建已开始处理',
            tokenId: tokenRecord._id 
        });
        
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

async function processTokenCreation(tokenRecord, data) {
    try {
        const { name, symbol, twitterHandle, liquidity } = data;
        
        // 1. 注册Twitter用户
        await registerTwitterUser(twitterHandle, tokenRecord);
        
        // 2. 创建代币
        const result = await createTokenContract(
            twitterHandle,
            name,
            symbol,
            liquidity,
            tokenRecord
        );
        
        // 3. 更新数据库
        tokenRecord.address = result.tokenAddress;
        tokenRecord.txHash = result.txHash;
        tokenRecord.liquidity = liquidity;
        tokenRecord.status = 'completed';
        await tokenRecord.save();
        
        // 4. 发送成功推文
        const tweetText = `✅ @${twitterHandle} 您的代币 ${name} (${symbol}) 已创建成功！\n\n` +
                         `合约地址: ${result.tokenAddress}\n` +
                         `BSCScan: https://bscscan.com/token/${result.tokenAddress}\n` +
                         `PancakeSwap: https://pancakeswap.finance/swap?outputCurrency=${result.tokenAddress}`;
        
        await twitterClient.v2.tweet(tweetText);
        
    } catch (error) {
        console.error('创建代币失败:', error);
        
        // 更新状态为失败
        tokenRecord.status = 'failed';
        tokenRecord.error = error.message;
        await tokenRecord.save();
        
        // 发送失败通知
        await twitterClient.v2.tweet(
            `@${twitterHandle} 抱歉，创建代币 ${tokenRecord.name} 时出错: ${error.message}`
        );
    }
}

async function registerTwitterUser(twitterHandle, tokenRecord) {
    const tx = await factoryContract.methods
        .registerTwitterUser(twitterHandle)
        .send({
            from: wallet.address,
            gas: 200000
        });
    
    tokenRecord.registerTx = tx.transactionHash;
    await tokenRecord.save();
}

async function createTokenContract(twitterHandle, name, symbol, liquidity, tokenRecord) {
    const weiAmount = web3.utils.toWei(liquidity.toString(), 'ether');
    const creationFee = await factoryContract.methods.creationFee().call();
    const totalValue = parseInt(creationFee) + parseInt(weiAmount);
    
    const tx = await factoryContract.methods
        .createTokenForTwitterUser(twitterHandle, name, symbol, weiAmount)
        .send({
            from: wallet.address,
            value: totalValue,
            gas: 2000000
        });
    
    // 解析事件
    const event = tx.events.TokenCreatedViaTwitter.returnValues;
    
    return {
        tokenAddress: event.token,
        txHash: tx.transactionHash
    };
}

// Twitter Webhook 用于接收推文
app.post('/api/twitter/webhook', async (req, res) => {
    try {
        const tweet = req.body.tweet_create_events?.[0];
        
        if (tweet) {
            await handleTweet(tweet);
        }
        
        res.status(200).send('OK');
    } catch (error) {
        console.error('Webhook错误:', error);
        res.status(500).send('Error');
    }
});

async function handleTweet(tweet) {
    const text = tweet.text;
    const userId = tweet.user.id_str;
    const username = tweet.user.screen_name;
    
    // 解析命令
    const command = parseTweetCommand(text);
    
    if (command) {
        // 处理代币创建请求
        await processTweetCreation(username, command, tweet.id_str);
    }
}

function parseTweetCommand(text) {
    const patterns = [
        /创建代币\s+([A-Za-z0-9]+)\s+([A-Z]{3,6})/i,
        /create token\s+([A-Za-z0-9]+)\s+([A-Z]{3,6})/i,
    ];
    
    for (const pattern of patterns) {
        const match = text.match(pattern);
        if (match) {
            return {
                name: match[1],
                symbol: match[2].toUpperCase()
            };
        }
    }
    
    return null;
}

async function processTweetCreation(username, command, tweetId) {
    try {
        // 发送确认回复
        await twitterClient.v2.tweet(
            `@${username} 确认创建代币 ${command.name} (${command.symbol})？\n\n` +
            `请回复 '确认' 继续。\n` +
            `费用: 0.1 BNB + 初始流动性`,
            { reply: { in_reply_to_tweet_id: tweetId } }
        );
        
    } catch (error) {
        console.error('处理推文失败:', error);
    }
}

// 启动服务器
app.listen(port, () => {
    console.log(`服务器运行在 http://localhost:${port}`);
});
