# main.py - ä¸»è¦æœºå™¨äººæœåŠ¡
import tweepy
import asyncio
import json
import re
from web3 import Web3
from datetime import datetime
from typing import Dict, Optional
import logging

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class XTokenCreatorBot:
    def __init__(self):
        # Twitter/X API é…ç½®
        self.api_key = "your_api_key"
        self.api_secret = "your_api_secret"
        self.access_token = "your_access_token"
        self.access_secret = "your_access_secret"
        self.bearer_token = "your_bearer_token"
        
        # BSCç½‘ç»œé…ç½®
        self.bsc_rpc = "https://bsc-dataseed.binance.org/"
        self.web3 = Web3(Web3.HTTPProvider(self.bsc_rpc))
        
        # åˆçº¦åœ°å€
        self.token_factory_address = "0xYourFactoryAddress"
        self.token_factory_abi = [...]  # Factory ABI
        
        # é’±åŒ…é…ç½®
        self.private_key = "your_private_key"
        self.wallet_address = "your_wallet_address"
        
        # åˆå§‹åŒ–åˆçº¦
        self.factory_contract = self.web3.eth.contract(
            address=self.token_factory_address,
            abi=self.token_factory_abi
        )
        
        # åˆå§‹åŒ–Twitterå®¢æˆ·ç«¯
        self.client = tweepy.Client(
            bearer_token=self.bearer_token,
            consumer_key=self.api_key,
            consumer_secret=self.api_secret,
            access_token=self.access_token,
            access_token_secret=self.access_secret
        )
        
        # å­˜å‚¨ç”¨æˆ·ä¼šè¯
        self.user_sessions = {}
        
    def parse_tweet_command(self, text: str) -> Optional[Dict]:
        """è§£ææ¨æ–‡ä¸­çš„åˆ›å»ºä»£å¸å‘½ä»¤"""
        patterns = [
            r'åˆ›å»ºä»£å¸\s+([A-Za-z0-9]+)\s+([A-Z]{3,6})',  # ä¸­æ–‡
            r'create token\s+([A-Za-z0-9]+)\s+([A-Z]{3,6})',  # è‹±æ–‡
            r'ä»£å¸:\s*([A-Za-z0-9]+)\s+ç¬¦å·:\s*([A-Z]{3,6})',
            r'#å‘å¸\s+([A-Za-z0-9]+)\s+([A-Z]{3,6})',
            r'#LaunchToken\s+([A-Za-z0-9]+)\s+([A-Z]{3,6})',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                return {
                    'name': match.group(1).strip(),
                    'symbol': match.group(2).strip().upper()
                }
        return None
    
    async def process_mention(self, tweet):
        """å¤„ç†æåŠæœºå™¨äººçš„æ¨æ–‡"""
        try:
            tweet_id = tweet.id
            user_id = tweet.author_id
            username = tweet.author.username
            text = tweet.text
            
            logger.info(f"æ”¶åˆ°æ¥è‡ª @{username} çš„æ¨æ–‡: {text}")
            
            # è§£æå‘½ä»¤
            token_info = self.parse_tweet_command(text)
            if not token_info:
                # å‘é€å¸®åŠ©ä¿¡æ¯
                self.reply_with_help(tweet_id)
                return
            
            # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²åˆ›å»ºè¿‡ä»£å¸
            if await self.check_user_limit(user_id):
                self.reply_error(tweet_id, "å·²è¾¾åˆ°æ¯æ—¥åˆ›å»ºé™åˆ¶")
                return
            
            # å‘é€ç¡®è®¤æ¶ˆæ¯
            confirm_tweet = self.client.create_tweet(
                text=f"@{username} ç¡®è®¤åˆ›å»ºä»£å¸ {token_info['name']} ({token_info['symbol']})ï¼Ÿ\n\n"
                     f"è¯·å›å¤ 'ç¡®è®¤' ç»§ç»­ï¼Œæˆ– 'å–æ¶ˆ' ä¸­æ­¢ã€‚\n"
                     f"è´¹ç”¨: 0.1 BNB + åˆå§‹æµåŠ¨æ€§",
                in_reply_to_tweet_id=tweet_id
            )
            
            # å­˜å‚¨ä¼šè¯
            self.user_sessions[user_id] = {
                'token_info': token_info,
                'confirm_tweet_id': confirm_tweet.data['id'],
                'original_tweet_id': tweet_id,
                'status': 'awaiting_confirmation'
            }
            
        except Exception as e:
            logger.error(f"å¤„ç†æ¨æ–‡æ—¶å‡ºé”™: {e}")
    
    async def process_confirmation(self, tweet):
        """å¤„ç†ç”¨æˆ·çš„ç¡®è®¤å›å¤"""
        try:
            user_id = tweet.author_id
            text = tweet.text.lower()
            
            if user_id not in self.user_sessions:
                return
            
            session = self.user_sessions[user_id]
            
            if 'ç¡®è®¤' in text or 'confirm' in text:
                # ç”¨æˆ·ç¡®è®¤ï¼Œå¼€å§‹åˆ›å»ºä»£å¸
                self.client.create_tweet(
                    text=f"@{tweet.author.username} æ­£åœ¨åˆ›å»ºä»£å¸ï¼Œè¯·ç¨å€™... â³",
                    in_reply_to_tweet_id=session['original_tweet_id']
                )
                
                # åˆ›å»ºä»£å¸
                result = await self.create_token(session['token_info'], user_id)
                
                if result['success']:
                    # å‘é€æˆåŠŸæ¶ˆæ¯
                    success_text = (
                        f"âœ… ä»£å¸åˆ›å»ºæˆåŠŸï¼\n\n"
                        f"åç§°: {result['name']}\n"
                        f"ç¬¦å·: {result['symbol']}\n"
                        f"åˆçº¦åœ°å€: {result['address']}\n"
                        f"BSCScan: https://bscscan.com/token/{result['address']}\n"
                        f"PancakeSwap: https://pancakeswap.finance/swap?outputCurrency={result['address']}\n\n"
                        f"ğŸ’§ æµåŠ¨æ€§å·²è‡ªåŠ¨é”å®š\n"
                        f"ğŸ“Š ä»£å¸ä¿¡æ¯å·²é…ç½®å®Œæˆ"
                    )
                    
                    self.client.create_tweet(
                        text=success_text,
                        in_reply_to_tweet_id=session['original_tweet_id']
                    )
                    
                    # è®°å½•ç”¨æˆ·åˆ›å»º
                    await self.record_user_creation(user_id)
                    
                else:
                    # å‘é€é”™è¯¯æ¶ˆæ¯
                    self.client.create_tweet(
                        text=f"âŒ åˆ›å»ºå¤±è´¥: {result['error']}",
                        in_reply_to_tweet_id=session['original_tweet_id']
                    )
                    
                # æ¸…ç†ä¼šè¯
                del self.user_sessions[user_id]
                
            elif 'å–æ¶ˆ' in text or 'cancel' in text:
                self.client.create_tweet(
                    text=f"@{tweet.author.username} å·²å–æ¶ˆä»£å¸åˆ›å»º",
                    in_reply_to_tweet_id=session['original_tweet_id']
                )
                del self.user_sessions[user_id]
                
        except Exception as e:
            logger.error(f"å¤„ç†ç¡®è®¤æ—¶å‡ºé”™: {e}")
    
    async def create_token(self, token_info: Dict, user_id: str) -> Dict:
        """åœ¨BSCé“¾ä¸Šåˆ›å»ºä»£å¸"""
        try:
            token_name = token_info['name']
            token_symbol = token_info['symbol']
            
            # é»˜è®¤å‚æ•°
            initial_liquidity = self.web3.to_wei(0.1, 'ether')  # 0.1 BNB
            
            # æ„å»ºäº¤æ˜“
            nonce = self.web3.eth.get_transaction_count(self.wallet_address)
            
            # è®¡ç®—æ€»è´¹ç”¨ï¼ˆåˆ›å»ºè´¹ + æµåŠ¨æ€§ï¼‰
            creation_fee = self.factory_contract.functions.creationFee().call()
            total_value = creation_fee + initial_liquidity
            
            # åˆ›å»ºäº¤æ˜“
            transaction = self.factory_contract.functions.createToken(
                token_name,
                token_symbol,
                initial_liquidity
            ).build_transaction({
                'from': self.wallet_address,
                'value': total_value,
                'gas': 2000000,
                'gasPrice': self.web3.to_wei('5', 'gwei'),
                'nonce': nonce,
                'chainId': 56  # BSCä¸»ç½‘
            })
            
            # ç­¾åäº¤æ˜“
            signed_txn = self.web3.eth.account.sign_transaction(
                transaction, self.private_key
            )
            
            # å‘é€äº¤æ˜“
            tx_hash = self.web3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            # ç­‰å¾…äº¤æ˜“ç¡®è®¤
            receipt = self.web3.eth.wait_for_transaction_receipt(tx_hash)
            
            # è§£ææ—¥å¿—è·å–ä»£å¸åœ°å€
            token_address = None
            for log in receipt['logs']:
                try:
                    decoded = self.factory_contract.events.TokenCreated().process_log(log)
                    if decoded:
                        token_address = decoded['args']['token']
                        break
                except:
                    continue
            
            if token_address:
                # è‡ªåŠ¨é…ç½®ä»£å¸
                await self.configure_token(token_address, user_id)
                
                return {
                    'success': True,
                    'name': token_name,
                    'symbol': token_symbol,
                    'address': token_address,
                    'tx_hash': tx_hash.hex()
                }
            else:
                return {
                    'success': False,
                    'error': 'æ— æ³•è·å–ä»£å¸åœ°å€'
                }
                
        except Exception as e:
            logger.error(f"åˆ›å»ºä»£å¸æ—¶å‡ºé”™: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def configure_token(self, token_address: str, user_id: str):
        """è‡ªåŠ¨é…ç½®ä»£å¸å‚æ•°"""
        try:
            # åŠ è½½ä»£å¸åˆçº¦ABI
            token_abi = [...]  # ä»£å¸åˆçº¦ABI
            token_contract = self.web3.eth.contract(
                address=token_address,
                abi=token_abi
            )
            
            # å¯ç”¨äº¤æ˜“
            nonce = self.web3.eth.get_transaction_count(self.wallet_address)
            
            tx = token_contract.functions.enableTrading().build_transaction({
                'from': self.wallet_address,
                'gas': 200000,
                'gasPrice': self.web3.to_wei('5', 'gwei'),
                'nonce': nonce,
                'chainId': 56
            })
            
            signed = self.web3.eth.account.sign_transaction(tx, self.private_key)
            self.web3.eth.send_raw_transaction(signed.rawTransaction)
            
            logger.info(f"å·²é…ç½®ä»£å¸ {token_address}")
            
        except Exception as e:
            logger.error(f"é…ç½®ä»£å¸æ—¶å‡ºé”™: {e}")
    
    def reply_with_help(self, tweet_id: str):
        """å‘é€å¸®åŠ©ä¿¡æ¯"""
        help_text = (
            "ğŸ¤– BAGSå¿«é€Ÿå‘å¸æœºå™¨äºº ğŸ¤–\n\n"
            "ä½¿ç”¨æ–¹æ³•:\n"
            "1. æåŠæˆ‘å¹¶è¾“å…¥: åˆ›å»ºä»£å¸ [åç§°] [ç¬¦å·]\n"
            "   ä¾‹å¦‚: @BagsBot åˆ›å»ºä»£å¸ MyToken MYK\n\n"
            "2. æˆ‘ä¼šå›å¤ç¡®è®¤ä¿¡æ¯\n"
            "3. å›å¤'ç¡®è®¤'å¼€å§‹åˆ›å»º\n\n"
            "âš ï¸ è´¹ç”¨: 0.1 BNB + åˆå§‹æµåŠ¨æ€§\n"
            "âœ… è‡ªåŠ¨é”å®šæµåŠ¨æ€§\n"
            "âœ… è‡ªåŠ¨é…ç½®äº¤æ˜“å‚æ•°\n"
            "âœ… è‡ªåŠ¨ä¸Šçº¿PancakeSwap"
        )
        
        try:
            self.client.create_tweet(
                text=help_text,
                in_reply_to_tweet_id=tweet_id
            )
        except Exception as e:
            logger.error(f"å‘é€å¸®åŠ©ä¿¡æ¯æ—¶å‡ºé”™: {e}")
    
    def reply_error(self, tweet_id: str, error_msg: str):
        """å‘é€é”™è¯¯ä¿¡æ¯"""
        try:
            self.client.create_tweet(
                text=f"âŒ é”™è¯¯: {error_msg}",
                in_reply_to_tweet_id=tweet_id
            )
        except Exception as e:
            logger.error(f"å‘é€é”™è¯¯ä¿¡æ¯æ—¶å‡ºé”™: {e}")
    
    async def check_user_limit(self, user_id: str) -> bool:
        """æ£€æŸ¥ç”¨æˆ·åˆ›å»ºé™åˆ¶"""
        # å®ç°ç”¨æˆ·é™åˆ¶é€»è¾‘ï¼Œä¾‹å¦‚æ¯å¤©æœ€å¤šåˆ›å»º3ä¸ªä»£å¸
        # è¿™é‡Œå¯ä»¥é›†æˆæ•°æ®åº“æˆ–ç¼“å­˜
        return False
    
    async def record_user_creation(self, user_id: str):
        """è®°å½•ç”¨æˆ·åˆ›å»ºè®°å½•"""
        # å®ç°è®°å½•é€»è¾‘
        pass
    
    async def start_listening(self):
        """å¼€å§‹ç›‘å¬æ¨æ–‡"""
        logger.info("å¯åŠ¨æ¨æ–‡ç›‘å¬æœåŠ¡...")
        
        # è·å–åˆå§‹æ¨æ–‡ID
        me = self.client.get_me()
        my_id = me.data.id
        
        # è®¾ç½®è§„åˆ™æµ
        rules = [
            {"value": f"@{me.data.username} åˆ›å»ºä»£å¸", "tag": "create_token"},
            {"value": f"@{me.data.username} create token", "tag": "create_token_en"},
            {"value": f"to:@{me.data.username} ç¡®è®¤", "tag": "confirmation"},
            {"value": f"to:@{me.data.username} confirm", "tag": "confirmation_en"},
        ]
        
        # ä½¿ç”¨æµå¼APIç›‘å¬
        class TweetStream(tweepy.StreamingClient):
            def __init__(self, bearer_token, bot_instance):
                super().__init__(bearer_token)
                self.bot = bot_instance
            
            async def on_tweet(self, tweet):
                if tweet.referenced_tweets:
                    # å›å¤æ¨æ–‡
                    await self.bot.process_confirmation(tweet)
                else:
                    # æ–°æ¨æ–‡
                    await self.bot.process_mention(tweet)
        
        stream = TweetStream(self.bearer_token, self)
        
        # å…ˆåˆ é™¤ç°æœ‰è§„åˆ™
        existing_rules = stream.get_rules().data
        if existing_rules:
            stream.delete_rules([rule.id for rule in existing_rules])
        
        # æ·»åŠ æ–°è§„åˆ™
        stream.add_rules(rules)
        
        # å¼€å§‹ç›‘å¬
        stream.filter(
            expansions=["author_id", "referenced_tweets.id"],
            tweet_fields=["conversation_id", "created_at"]
        )

# å¯åŠ¨æœºå™¨äºº
if __name__ == "__main__":
    bot = XTokenCreatorBot()
    asyncio.run(bot.start_listening())
